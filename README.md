# 자바의 정석 스터디
> ### 6장 객체지향 프로그래밍1
1.1 **객체지향언어**   
    * 코드의 재사용성이 높음   
    * 코드의 관리가 용이   
    * 신뢰성 높은 프로그래밍을 가능       
    
2.1 **클래스와 객체**  
    * 클래스의 정의 - 클래스란 객체를 정의해 놓은 것이다.   
    * 클래스의 용도 - 클래스는 객체를 생성하는데 사용된다.   
    * 객체의 정의 - 실제로 존재하는 것, 사물 또는 개념   
    * 객체의 용도 - 객체가 가지고 있는 기능과 속성에 따라 다름      
    '<u>프로그래밍에서의 객체는 클래스에 정의된 내용대로 **메모리에 생성**된 것을 뜻한다.</u>'
      
2.2 객체와 인스턴스   
클래스에서 객체로 만들어지는 과정을 **클래스의 인스턴스화**라고 하며,   
어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.

2.3 객체의 구성요소 - 속성과 기능   
**속성(property)** - 멤버변수, 특성, 필드, 상태   
**기능(function)** - 메서드, 함수, 행위

2.4 인스턴스의 생성과 사용   
'<u>인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야한다.</u>'

2.6 클래스의 또 다른 정의
1) 클래스 - 데이터와 함수의 결합   
서로 관련된 변수들을 정의하고 이들에 대한 작업을 수행하는 함수들을 함께 정의한 것이 클래스
2) 클래스 - 사용자정의 타입   
기본형 타입 8개를 제외한 타입들이 사용자정의 타입이 될 수 있다.
   

3.1 선언위치에 따른 변수의 종류
<pre><code>class Varialbes {
    int iv;         // 인스턴스 변수
    static int cv;  // 클래스 변수

    void method() {
        int lv = 0; // 지역 변수
    }
}</code></pre>
* 클래스 변수 - 선언위치 : 클래스, 생성시기 : 클래스가 메모리에 올라갈 때
* 인스턴스 변수 - 선언위치 : 클래스, 생성시기 : 인스턴스가 생성되었을 때
* 지역 변수 - 선언위치 : 메서드, 생성시기 : 변수 선언문이 수행되었을 

3.6 return문
* 반환타입이 void인 경우, return문 업시도 아무런 문제가 없었던 이유는 컴파일러가 메서드 마지막에   
'return;'을 자동적으로 추가하였기 때문   
  
3.7 JVM의 메모리 구조
* 메서드 영역(Method area) - JVM은 해당 클래스의 클래스파일을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다 이 때, 그 클래스의 클래스변수도 이 영역에 함꼐 생성
* 힙(Heap) - 인스턴스가 생성되는 공간, 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다. 즉, 인스턴스변수들이 생성되는 공간이다.
* 호출스택(call stack) - 메서드 작업에 필요한 메모리 공간을 제공. 호출 스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작어을 수행하는 동안 지역변수들과 연산의 중간결과 등을 저장하는데 사용된다. 그리고 메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 비워진다.   

3.8 기본형 매개변수와 참조형 매개변수   
* **기본형 매개변수** - 변수의 값을 읽기만 할 수 있다. (read only)
* **참조형 매개변수** - 변수의 값을 읽고 변경할 수 있다. (read & write)

3.11 클래스 메서드(static메서드)와 인스턴스 메서드    
1. 클래스를 설게할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.
2. 클래스 변수(static변수) 는 인스턴스를 생성하지 않고 사용할 수 있다.
3. 클래스 메서드(static메서드)는 인스턴스 변수를 사용할 수 없다.
4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려   
인스턴스변수를 필요로 하지 않는다면 static을 붙이자. 메서드 호출시간이 짧아지므로 성능이 향상된다. 

4.1 오버로딩이란 - 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것
4.2 오버로딩의 조건
1. 메서드 이름이 같아야 함
2. 매개변수의 개수 또는 타입이 달라야 한다.

4.4 오버로딩의 장점
* 하나의 이름으로 정의하면 기억하기도 쉽고, 메서드의 이름을 절약할 수 있다.   

4.5 가변인자(varargs)와 오버로딩

5.1 생성자란 - 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드'   
1. 생성자의 이름은 클래스의 이름과 같아야 함
2. 생성자는 리턴 값이 없음 - 모든 생성자는 리턴값이 없으므로 void를 붙이지 않는다.   
> 연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다.   

5.2 기본 생성자
* 모든 클래스는 반드시 하나 이상의 생성자가 정의 되어 있어야 한다.
* 컴파일 할 때, 소스파일의 클래스에 생성자가 하나도 정의되지 않은 경우 컴파일러는 자동적으로 기본 생성자를 추가한다.   
* 컴파일러가 자동적으로 기본 생성자를 추가해주는 경우는 **클래스 내에 생성자가 하나도 없을 때**
<pre><code>클래스이름() {}</code></pre>   

5.4 생성자에서 다른 생성자 호출하기 - this(), this
* 같은 클래스 내에 생성자 간에도 서로 호출이 가능한데 두 조건을 만족해야한다.
1. 생성자의 이름으로 클래스 이름 대신 this를 사용한다.
2. 한 생성자에서 다른 생성자를 호출 할 때는 반드시 첫 줄에서만 호출이 가능하다.
> **this** 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다.    
> 모든 인스턴스메서드에 지역변수로 숨겨진 채로 존재한다.   
> **this(), this(매개변수)** 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다.

6.1 변수의 초기화   
> 멤버변수(클래스 변수와 인스턴스 변수)와 배열의 초기화는 선택적이지만, 지역변수의 초기화는 필수적이다.   
* 멤버변수 초기화 방법   
> 1. 명시적 초기화
> 2. 생성자
> 3. 초기화 블럭
<pre><code>class IntBlock {
    static { /* 클래스 초기화블럭 입니다. */ }
        { /* 인스턴스 초기호블럭 입니다. */ }
}</code></pre>








   







 